name: Deploy to TestFlight

on:
  workflow_dispatch:
    inputs:
      project_data:
        description: 'Project data JSON (from your app)'
        required: false
        type: string
        default: '{}'
      app_name:
        description: 'App name for the build'
        required: true
        type: string
        default: 'NoCodeApp'
      bundle_id:
        description: 'Bundle ID (used if project_data not provided)'
        required: false
        type: string
        default: 'com.visios.nocode'
      version:
        description: 'App Version (used if project_data not provided)'
        required: false
        type: string
        default: '1.0.1'
      build_number:
        description: 'Build Number (used if project_data not provided)'
        required: false
        type: string
        default: '1'
      backend_url:
        description: 'Backend URL for app generation (or use BACKEND_URL secret)'
        required: false
        type: string
        default: ''
      firebase_token:
        description: 'Firebase authentication token from frontend'
        required: false
        type: string
        default: ''
      preloaded_data:
          description: 'Preloaded Firebase data as JSON string to bypass private IP'
          required: false
          type: string
          default: ''

jobs:
  deploy-testflight:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
        
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.19.0'
        channel: 'stable'
        
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
        
    - name: Create Flutter project structure
      run: |
        echo "🏗️ Creating Flutter project structure..."
        
        # Parse project data to extract app info
        echo "📊 Parsing project configuration..."
        PROJECT_DATA='${{ github.event.inputs.project_data }}'
        APP_NAME='${{ github.event.inputs.app_name }}'
        
        # Check if we have meaningful project_data (not just empty {})
        if [ "$PROJECT_DATA" != "{}" ] && [ "$PROJECT_DATA" != "" ]; then
          echo "📱 Using project_data for app configuration"
          # Extract deployment info from project data
          BUNDLE_ID=$(echo "$PROJECT_DATA" | jq -r '.deploymentInfo.bundleId // "${{ github.event.inputs.bundle_id }}"')
          VERSION=$(echo "$PROJECT_DATA" | jq -r '.deploymentInfo.version // "${{ github.event.inputs.version }}"')
          # Always generate fresh build number to avoid conflicts, ignore any existing buildNumber
          BUILD_NUMBER=$(date +%s)
          USE_PROJECT_DATA=true
          echo "🔄 Generated fresh build number: $BUILD_NUMBER (ignoring any existing buildNumber)"
          
          # Auto-enable backend fetching if projectId is present
          PROJECT_ID=$(echo "$PROJECT_DATA" | jq -r '.projectId // empty')
          if [ -n "$PROJECT_ID" ] && [ "$PROJECT_ID" != "null" ]; then
            echo "🔍 Project ID detected: $PROJECT_ID - enabling backend fetch"
            # Create minimal project data to force backend fetch (strip all local template data)
            PROJECT_DATA=$(echo "$PROJECT_DATA" | jq '{
              templateId: .templateId,
              projectId: .projectId,
              deploymentInfo: .deploymentInfo,
              fetchFromBackend: true
            }')
            echo "✅ Stripped local template data and enabled backend fetch"
            echo "🔍 Minimal project data after stripping: $(echo "$PROJECT_DATA" | jq -c .)"
          fi
        else
          echo "📱 Using manual inputs for app configuration"
          # Use manual inputs but generate fresh build number
          BUNDLE_ID='${{ github.event.inputs.bundle_id }}'
          VERSION='${{ github.event.inputs.version }}'
          # Always generate fresh build number instead of using potentially old default
          BUILD_NUMBER=$(date +%s)
          USE_PROJECT_DATA=false
          echo "🔄 Generated fresh build number: $BUILD_NUMBER (instead of manual input)"
          # Create minimal project data for backend call
          PROJECT_DATA='{"templateId":"default","projectId":"github-action-build","template":{},"deploymentInfo":{"appName":"'$APP_NAME'","bundleId":"'$BUNDLE_ID'","version":"'$VERSION'","buildNumber":"'$BUILD_NUMBER'"}}'
        fi
        
        echo "📱 Final App Configuration:"
        echo "   Name: $APP_NAME"
        echo "   Bundle ID: $BUNDLE_ID"
        echo "   Version: $VERSION"
        echo "   Build Number: $BUILD_NUMBER"
        echo "   Using Project Data: $USE_PROJECT_DATA"
        
        # Store minimal environment for later steps (avoid exporting large JSON)
        echo "BUNDLE_ID=$BUNDLE_ID" >> $GITHUB_ENV
        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
        echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
        
        mkdir -p flutter_project
        cd flutter_project
        
        # Initialize Flutter project
        flutter create . --org=$BUNDLE_ID --project-name=app
        
        # Create the app using our backend service
        echo "📱 Generating app from backend..."
        
        # Use BACKEND_URL secret if available, otherwise use input
        BACKEND_URL='${{ secrets.BACKEND_URL }}'
        if [ -z "$BACKEND_URL" ]; then
          BACKEND_URL='${{ github.event.inputs.backend_url }}'
        fi
        
        # Set Firebase service token for backend authentication
        export FIREBASE_SERVICE_TOKEN='${{ secrets.FIREBASE_SERVICE_TOKEN }}'
        
        if [ -z "$BACKEND_URL" ]; then
          echo "❌ No backend URL provided! Please set BACKEND_URL secret or provide backend_url input"
          exit 1
        fi
        
        echo "🌐 Using backend URL: $BACKEND_URL"
        
        # Add Firebase service token and correct Firebase base URL to project data
        PROJECT_DATA=$(echo "$PROJECT_DATA" | jq -c . 2>/dev/null || echo "$PROJECT_DATA")
        
        # Add Firebase authentication token (prioritize separate input over embedded token)
        FIREBASE_TOKEN_INPUT='${{ github.event.inputs.firebase_token }}'
        USER_TOKEN_FROM_DATA=$(echo "$PROJECT_DATA" | jq -r '.userFirebaseToken // empty')
        PRELOADED_DATA_INPUT='${{ github.event.inputs.preloaded_data }}'
        
        echo "🔍 DEBUG: Checking for Firebase tokens..."
        echo "🔍 DEBUG: Firebase token from separate input: ${FIREBASE_TOKEN_INPUT:0:20}...${FIREBASE_TOKEN_INPUT:+present}" 
        echo "🔍 DEBUG: Firebase token from project data: ${USER_TOKEN_FROM_DATA:0:20}...${USER_TOKEN_FROM_DATA:+present}"
        echo "🔍 DEBUG: Service token available: ${FIREBASE_SERVICE_TOKEN:+present}"
        echo "🔍 DEBUG: Preloaded data input length: ${#PRELOADED_DATA_INPUT}"
        
        # Prioritize separate input token, then embedded token, then service token
        if [ -n "$FIREBASE_TOKEN_INPUT" ] && [ "$FIREBASE_TOKEN_INPUT" != "" ]; then
          echo "🔑 Using Firebase token from separate workflow input"
          PROJECT_DATA=$(echo "$PROJECT_DATA" | jq --arg token "$FIREBASE_TOKEN_INPUT" '. + {firebaseToken: $token}')
        elif [ -n "$USER_TOKEN_FROM_DATA" ] && [ "$USER_TOKEN_FROM_DATA" != "null" ] && [ "$USER_TOKEN_FROM_DATA" != "empty" ]; then
          echo "🔑 Using Firebase token from project data"
          PROJECT_DATA=$(echo "$PROJECT_DATA" | jq --arg token "$USER_TOKEN_FROM_DATA" '. + {firebaseToken: $token}')
        elif [ -n "$FIREBASE_SERVICE_TOKEN" ]; then
          echo "🔑 Using service token as fallback for backend authentication"
          PROJECT_DATA=$(echo "$PROJECT_DATA" | jq --arg token "$FIREBASE_SERVICE_TOKEN" '. + {firebaseToken: $token}')
        else
          echo "⚠️  Warning: No authentication token provided - backend may not be able to fetch project data"
          echo "   - Separate input token: ${FIREBASE_TOKEN_INPUT:-MISSING}"
          echo "   - Project data token: ${USER_TOKEN_FROM_DATA:-MISSING}"
          echo "   - Service token: ${FIREBASE_SERVICE_TOKEN:-MISSING}"
        fi
        
        # Clean up embedded token to avoid duplication
        PROJECT_DATA=$(echo "$PROJECT_DATA" | jq 'del(.userFirebaseToken)')
        
        # Add preloaded data if available (bypass private IP issue)
        if [ -n "$PRELOADED_DATA_INPUT" ] && [ "$PRELOADED_DATA_INPUT" != "" ]; then
          echo "🎯 Adding preloaded Firebase data to bypass private IP issue"
          echo "🔍 DEBUG: Preloaded data size: ${#PRELOADED_DATA_INPUT} characters"
          # Parse and add preloaded data to project data
          PROJECT_DATA=$(echo "$PROJECT_DATA" | jq --argjson preloaded "$PRELOADED_DATA_INPUT" '. + {preloadedFirebaseData: $preloaded}')
          echo "✅ Preloaded data successfully added to project data"
        else
          echo "⚠️ No preloaded data provided - will use API fetching"
        fi
        
        # Set correct Firebase API base URL (different from backend URL)
        FIREBASE_API_URL="${FIREBASE_API_BASE_URL:-http://10.80.7.189:3200}"
        echo "🌐 Using Firebase API URL: $FIREBASE_API_URL"
        PROJECT_DATA=$(echo "$PROJECT_DATA" | jq --arg fb "$FIREBASE_API_URL" '. + {firebaseBaseUrl: $fb}')
        echo "📋 Final project data being sent:"
        echo "🔍 DEBUG: Final project data keys: $(echo "$PROJECT_DATA" | jq -r 'keys[]' 2>/dev/null || echo 'JSON parse failed')"
        echo "🔍 DEBUG: firebaseToken present in final data: $(echo "$PROJECT_DATA" | jq -r 'has("firebaseToken")' 2>/dev/null || echo 'false')"
        echo "🔍 DEBUG: preloadedFirebaseData present: $(echo "$PROJECT_DATA" | jq -r 'has("preloadedFirebaseData")' 2>/dev/null || echo 'false')"
        if [ "$(echo "$PROJECT_DATA" | jq -r 'has("preloadedFirebaseData")' 2>/dev/null)" = "true" ]; then
          echo "🔍 DEBUG: preloaded screens count: $(echo "$PROJECT_DATA" | jq -r '.preloadedFirebaseData.screensData | length' 2>/dev/null || echo '0')"
        fi
        echo "$PROJECT_DATA" | jq '.' 2>/dev/null || echo "$PROJECT_DATA"
        curl -X POST "$BACKEND_URL/api/package-flutter" \
          -H "Content-Type: application/json" \
          -d "$PROJECT_DATA" \
          --output app_package.zip
          
        # Extract the generated app
        echo "📦 Extracting generated Flutter app..."
        unzip -o app_package.zip
        
        # Quick check of generated code
        echo "🔍 Quick check of generated main.dart:"
        if [ -f lib/main.dart ]; then
          echo "✅ main.dart exists"
          grep -n "primarySwatch\|ColorScheme.fromSeed\|toolbarHeight" lib/main.dart | head -5 || echo "No theme/appbar matches found"
        else
          echo "❌ main.dart not found"
        fi

        # Ensure ios/Runner/Info.plist has the correct version and build number
        echo "🔧 Ensuring ios/Runner/Info.plist has correct MARKETING_VERSION and CURRENT_PROJECT_VERSION..."
        if [ -f ios/Runner/Info.plist ]; then
          echo "📋 Before patch:" 
          /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" ios/Runner/Info.plist || echo "(no CFBundleShortVersionString)"
          /usr/libexec/PlistBuddy -c "Print :CFBundleVersion" ios/Runner/Info.plist || echo "(no CFBundleVersion)"
 
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" ios/Runner/Info.plist 2>/dev/null \
            || /usr/libexec/PlistBuddy -c "Add :CFBundleShortVersionString string $VERSION" ios/Runner/Info.plist
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD_NUMBER" ios/Runner/Info.plist 2>/dev/null \
            || /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $BUILD_NUMBER" ios/Runner/Info.plist
 
          # Ensure app icon keys exist
          /usr/libexec/PlistBuddy -c "Set :CFBundleIconName AppIcon" ios/Runner/Info.plist 2>/dev/null \
            || /usr/libexec/PlistBuddy -c "Add :CFBundleIconName string AppIcon" ios/Runner/Info.plist
          /usr/libexec/PlistBuddy -c "Add :CFBundleIcons dict" ios/Runner/Info.plist 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :CFBundleIcons:CFBundlePrimaryIcon dict" ios/Runner/Info.plist 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :CFBundleIcons:CFBundlePrimaryIcon:CFBundleIconFiles array" ios/Runner/Info.plist 2>/dev/null || true
          # Add AppIcon entry to icon files if not present
          if ! /usr/libexec/PlistBuddy -c "Print :CFBundleIcons:CFBundlePrimaryIcon:CFBundleIconFiles" ios/Runner/Info.plist | grep -q AppIcon; then
            /usr/libexec/PlistBuddy -c "Add :CFBundleIcons:CFBundlePrimaryIcon:CFBundleIconFiles:0 string AppIcon" ios/Runner/Info.plist 2>/dev/null || true
          fi
          /usr/libexec/PlistBuddy -c "Set :CFBundleIcons:CFBundlePrimaryIcon:UIPrerenderedIcon true" ios/Runner/Info.plist 2>/dev/null \
            || /usr/libexec/PlistBuddy -c "Add :CFBundleIcons:CFBundlePrimaryIcon:UIPrerenderedIcon bool true" ios/Runner/Info.plist

          echo "✅ After patch:"
          /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" ios/Runner/Info.plist
          /usr/libexec/PlistBuddy -c "Print :CFBundleVersion" ios/Runner/Info.plist
          /usr/libexec/PlistBuddy -c "Print :CFBundleIconName" ios/Runner/Info.plist || echo "(no CFBundleIconName)"
          echo "📦 CFBundleIcons present?"
          /usr/libexec/PlistBuddy -c "Print :CFBundleIcons" ios/Runner/Info.plist || echo "(no CFBundleIcons)"
        else
          echo "❌ ios/Runner/Info.plist not found after extraction"
          ls -la ios || true
        fi

        # Ensure required app icons exist (generate placeholders if missing)
        echo "🎨 Ensuring required AppIcon PNGs exist..."
        ICONSET="ios/Runner/Assets.xcassets/AppIcon.appiconset"
        mkdir -p "$ICONSET"
        # Create a function to generate a solid placeholder using sips
        gen_icon() { local size=$1; local name=$2; if [ ! -f "$ICONSET/$name" ]; then sips -s format png --resampleHeightWidthMax "$size" /System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/ToolbarFavoritesIcon.icns --out "$ICONSET/$name" >/dev/null 2>&1 || true; fi }
        # iPhone sizes (include 120x120 required)
        gen_icon 40  "Icon-App-20x20@2x.png"
        gen_icon 60  "Icon-App-20x20@3x.png"
        gen_icon 58  "Icon-App-29x29@2x.png"
        gen_icon 87  "Icon-App-29x29@3x.png"
        gen_icon 80  "Icon-App-40x40@2x.png"
        gen_icon 120 "Icon-App-40x40@3x.png"
        gen_icon 120 "Icon-App-60x60@2x.png"
        gen_icon 180 "Icon-App-60x60@3x.png"
        # iPad sizes
        gen_icon 20  "Icon-App-20x20@1x~ipad.png"
        gen_icon 40  "Icon-App-20x20@2x~ipad.png"
        gen_icon 29  "Icon-App-29x29@1x~ipad.png"
        gen_icon 58  "Icon-App-29x29@2x~ipad.png"
        gen_icon 40  "Icon-App-40x40@1x~ipad.png"
        gen_icon 80  "Icon-App-40x40@2x~ipad.png"
        gen_icon 76  "Icon-App-76x76@1x~ipad.png"
        gen_icon 152 "Icon-App-76x76@2x~ipad.png"
        gen_icon 167 "Icon-App-83.5x83.5@2x~ipad.png"
        # marketing
        gen_icon 1024 "Icon-App-1024x1024@1x.png"
        echo "📂 AppIcon files present:"
        ls -1 "$ICONSET" || true
        
        # Create exportOptions.plist for later use
        echo "📝 Creating exportOptions.plist..."
        cat > ios/exportOptions.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>app-store</string>
            <key>teamID</key>
            <string>${{ secrets.APPLE_TEAM_ID }}</string>
            <key>uploadBitcode</key>
            <false/>
            <key>uploadSymbols</key>
            <true/>
            <key>compileBitcode</key>
            <false/>
            <key>signingStyle</key>
            <string>manual</string>
            <key>signingCertificate</key>
            <string>Apple Distribution</string>
        </dict>
        </plist>
        EOF
        
    - name: Configure iOS signing
      env:
        APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
        APP_STORE_CONNECT_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_PRIVATE_KEY }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        IOS_CERTIFICATE_P12: ${{ secrets.IOS_CERTIFICATE_P12 }}
        IOS_CERTIFICATE_PASSWORD: ${{ secrets.IOS_CERTIFICATE_PASSWORD }}
        IOS_PROVISIONING_PROFILE: ${{ secrets.IOS_PROVISIONING_PROFILE }}
      run: |
        echo "🔐 Setting up iOS code signing with manual certificates..."
        
        # Create private_keys directory for App Store Connect API
        mkdir -p ~/private_keys
        echo "$APP_STORE_CONNECT_PRIVATE_KEY" > ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8
        
        # Debug: Verify .p8 file creation and content
        echo "🔍 P8 FILE DEBUG: Verifying AuthKey file creation..."
        P8_FILE_PATH="~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8"
        echo "📁 P8 file path: $P8_FILE_PATH"
        
        if [ -f ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8 ]; then
          echo "✅ P8 file exists"
          echo "📊 File size: $(wc -c < ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8) bytes"
          echo "🔐 File permissions: $(ls -la ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          echo "📝 First line: $(head -n 1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          echo "📝 Last line: $(tail -n 1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          echo "📏 Line count: $(wc -l < ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          
          # Validate .p8 format
          if head -n 1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8 | grep -q "BEGIN PRIVATE KEY"; then
            echo "✅ P8 file has correct BEGIN header"
          else
            echo "❌ P8 file missing BEGIN PRIVATE KEY header"
          fi
          
          if tail -n 1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8 | grep -q "END PRIVATE KEY"; then
            echo "✅ P8 file has correct END footer"
          else
            echo "❌ P8 file missing END PRIVATE KEY footer"
          fi
        else
          echo "❌ P8 file does not exist!"
          echo "📁 Directory contents:"
          ls -la ~/private_keys/ || echo "Directory does not exist"
        fi
        
        # Set up manual signing with certificates (more reliable than automatic)
        if [ -n "$IOS_CERTIFICATE_P12" ] && [ -n "$IOS_CERTIFICATE_PASSWORD" ]; then
          echo "📋 Setting up manual signing certificates..."
          
          # Setup keychain
          security create-keychain -p "build-keychain-password" build.keychain
          security list-keychains -s build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "build-keychain-password" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain
          
          # Import certificate
          echo "$IOS_CERTIFICATE_P12" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P "$IOS_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/xcodebuild
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "build-keychain-password" build.keychain
          
          # Debug: Comprehensive certificate analysis after import
          echo "🔍 CERTIFICATE DEBUG: Analyzing imported certificate..."
          echo "📋 Certificate file info:"
          openssl pkcs12 -in certificate.p12 -nokeys -passin pass:"$IOS_CERTIFICATE_PASSWORD" | openssl x509 -noout -subject -dates -purpose || echo "Failed to analyze certificate with openssl"
          
          echo "📋 All certificates in keychain (detailed):"
          security find-identity -v build.keychain
          
          echo "📋 Certificates by type:"
          security find-identity -v -p codesigning build.keychain | grep -i "distribution" && echo "✅ Distribution certificates found" || echo "❌ No Distribution certificates"
          security find-identity -v -p codesigning build.keychain | grep -i "development" && echo "✅ Development certificates found" || echo "❌ No Development certificates"
          
          echo "📋 Certificate details for code signing:"
          security find-identity -v -p codesigning build.keychain
          
          # Install provisioning profile
          if [ -n "$IOS_PROVISIONING_PROFILE" ]; then
            mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
            echo "$IOS_PROVISIONING_PROFILE" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision
            
            # Get the provisioning profile UUID for manual signing
            PROFILE_UUID=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | plutil -extract UUID xml1 -o - - | xmllint --xpath "//string/text()" -)
            echo "📱 Provisioning Profile UUID: $PROFILE_UUID"
            echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV
          fi
          
          # Get certificate common name for code signing identity  
          echo "🔍 CERTIFICATE SELECTION: Finding the correct certificate..."
          
          # First, try to get Distribution certificate specifically (required for TestFlight)
          DIST_CERT=$(security find-identity -v -p codesigning build.keychain | grep -i "distribution" | head -n 1 | grep -o '"[^"]*"' | sed 's/"//g')
          
          if [ -n "$DIST_CERT" ]; then
            echo "🎯 Found Distribution certificate: $DIST_CERT"
            CERT_NAME="$DIST_CERT"
          else
            # Fallback to any certificate if Distribution not found
            CERT_NAME=$(security find-identity -v -p codesigning build.keychain | head -n 1 | grep -o '"[^"]*"' | sed 's/"//g')
            echo "⚠️ No Distribution certificate found, using first available: $CERT_NAME"
          fi
          
          echo "🔑 Selected Certificate Identity: $CERT_NAME"
          echo "CERT_NAME=$CERT_NAME" >> $GITHUB_ENV
          
          # Verify the certificate is correct for App Store distribution
          if echo "$CERT_NAME" | grep -qi "distribution"; then
            echo "✅ Using Distribution certificate (correct for TestFlight)"
          else
            echo "⚠️ Warning: Not using Distribution certificate - this may cause issues with TestFlight upload"
          fi
        else
          echo "❌ No manual signing certificates provided!"
          exit 1
        fi
        
        # Verify setup
        echo "🔍 Verifying signing setup..."
        echo "   Team ID: $APPLE_TEAM_ID"
        echo "   Bundle ID: com.visios.nocode"
        echo "   Certificate: $CERT_NAME"
        echo "   Profile UUID: $PROFILE_UUID"
        
    - name: Build iOS app
      run: |
        cd flutter_project
        echo "🔨 Building Flutter iOS app with manual signing..."
        
        # Simple approach: Remove and add signing settings  
        TEAM_ID="${{ secrets.APPLE_TEAM_ID }}"
        PROFILE_UUID="$PROFILE_UUID"
        
        echo "🔧 Configuring Runner target signing (manual) and Pods targets (automatic)..."
        
        # First, remove ALL existing signing settings from project
        sed -i '' '/CODE_SIGN_STYLE/d' ios/Runner.xcodeproj/project.pbxproj
        sed -i '' '/DEVELOPMENT_TEAM/d' ios/Runner.xcodeproj/project.pbxproj  
        sed -i '' '/PROVISIONING_PROFILE_SPECIFIER/d' ios/Runner.xcodeproj/project.pbxproj
        sed -i '' '/CODE_SIGN_IDENTITY/d' ios/Runner.xcodeproj/project.pbxproj
        
        # Only add manual signing to Runner's bundle identifier
        echo "			CODE_SIGN_STYLE = Manual;" > temp_runner_signing.txt
        echo "			DEVELOPMENT_TEAM = \"$TEAM_ID\";" >> temp_runner_signing.txt  
        echo "			PROVISIONING_PROFILE_SPECIFIER = \"$PROFILE_UUID\";" >> temp_runner_signing.txt
        echo "			CODE_SIGN_IDENTITY = \"$CERT_NAME\";" >> temp_runner_signing.txt
        
        # Insert signing settings only after Runner's bundle identifier
        sed -i '' '/PRODUCT_BUNDLE_IDENTIFIER = com\.visios\.nocode;/r temp_runner_signing.txt' ios/Runner.xcodeproj/project.pbxproj
        rm temp_runner_signing.txt
        
        echo "🔍 Signing settings added to project:"
        grep -E "(CODE_SIGN_STYLE|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER)" ios/Runner.xcodeproj/project.pbxproj || echo "No signing settings found"
        
        # Get dependencies first to regenerate Pods with clean settings
        echo "📦 Running flutter pub get to regenerate Pods..."
        flutter pub get
        
        # Ensure CocoaPods targets use automatic signing (DO NOT specify provisioning profiles)
        if [ -f "ios/Pods/Pods.xcodeproj/project.pbxproj" ]; then
          echo "🔧 Ensuring CocoaPods targets use automatic signing..."
          sed -i '' 's/CODE_SIGN_STYLE = Manual;/CODE_SIGN_STYLE = Automatic;/g' ios/Pods/Pods.xcodeproj/project.pbxproj
          sed -i '' 's/DEVELOPMENT_TEAM = "";/DEVELOPMENT_TEAM = "${{ secrets.APPLE_TEAM_ID }}";/g' ios/Pods/Pods.xcodeproj/project.pbxproj
          # COMPLETELY REMOVE any provisioning profile specifiers from Pods targets (not just empty them)
          sed -i '' '/PROVISIONING_PROFILE_SPECIFIER/d' ios/Pods/Pods.xcodeproj/project.pbxproj
        fi
        
        # Fix Pods/Pods-Runner targets for automatic signing (clear out any code signing that may be left)
        PBXPROJ="ios/Pods/Pods.xcodeproj/project.pbxproj"
        if [ -f "$PBXPROJ" ]; then
          echo "🔧 Completely removing all code signing from Pods targets"
          
          # Debug: Show Pods signing settings before cleanup
          echo "🔍 Pods signing settings before cleanup:"
          grep -E "(CODE_SIGN_STYLE|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER|CODE_SIGN_IDENTITY)" $PBXPROJ || echo "No signing settings found in Pods"
          
          # Set automatic signing for Pods
          sed -i '' 's/CODE_SIGN_STYLE = Manual;/CODE_SIGN_STYLE = Automatic;/g' $PBXPROJ
          
          # COMPLETELY REMOVE all problematic signing settings from Pods (not just empty them)
          sed -i '' '/PROVISIONING_PROFILE_SPECIFIER/d' $PBXPROJ  # Remove entire lines with provisioning profiles
          sed -i '' '/DEVELOPMENT_TEAM = .*/d' $PBXPROJ  # Remove DEVELOPMENT_TEAM lines from Pods
          sed -i '' '/CODE_SIGN_IDENTITY = .*/d' $PBXPROJ  # Remove CODE_SIGN_IDENTITY lines from Pods
          
          # Debug: Show Pods signing settings after cleanup
          echo "🔍 Pods signing settings after cleanup:"
          grep -E "(CODE_SIGN_STYLE|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER|CODE_SIGN_IDENTITY)" $PBXPROJ || echo "No signing settings found in Pods"
        fi
        
        # Final verification before build
        echo "🔍 Final check: Any provisioning profile in Pods pbxproj?"
        grep "PROVISIONING_PROFILE_SPECIFIER" ios/Pods/Pods.xcodeproj/project.pbxproj || echo "✅ All provisioning profiles removed from Pods."

        # Comprehensive CocoaPods cleanup and verification
        PBXPROJ="ios/Pods/Pods.xcodeproj/project.pbxproj"
        if [ -f "$PBXPROJ" ]; then
          echo "🔧 Comprehensive CocoaPods cleanup (removing ALL signing overrides)"
          
          # Debug: Show Pods signing settings before cleanup
          echo "🔍 Pods signing settings before cleanup:"
          grep -E "(CODE_SIGN_STYLE|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER|CODE_SIGN_IDENTITY)" $PBXPROJ || echo "No signing settings found in Pods"
          
          # Set automatic signing for all Pods targets
          sed -i '' 's/CODE_SIGN_STYLE = Manual;/CODE_SIGN_STYLE = Automatic;/g' $PBXPROJ
          
          # COMPLETELY REMOVE all problematic signing settings from Pods (not just empty them)
          # This prevents plugins like sqflite, shared_preferences from having ANY provisioning profile lines
          sed -i '' '/PROVISIONING_PROFILE_SPECIFIER/d' $PBXPROJ  # Remove entire lines with provisioning profiles
          sed -i '' '/DEVELOPMENT_TEAM = .*/d' $PBXPROJ  # Remove DEVELOPMENT_TEAM lines from Pods
          sed -i '' '/CODE_SIGN_IDENTITY = .*/d' $PBXPROJ  # Remove CODE_SIGN_IDENTITY lines from Pods
          
          # Debug: Show Pods signing settings after cleanup
          echo "🔍 Pods signing settings after cleanup:"
          grep -E "(CODE_SIGN_STYLE|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER|CODE_SIGN_IDENTITY)" $PBXPROJ || echo "No signing settings found in Pods"
        fi
        
        # Final verification before build
        echo "🔍 Final check: Any provisioning profile in Pods pbxproj?"
        grep "PROVISIONING_PROFILE_SPECIFIER" ios/Pods/Pods.xcodeproj/project.pbxproj || echo "✅ All provisioning profiles removed from Pods."
        
        # Build iOS with no code signing first
        echo "🔨 Building Flutter iOS app with explicit version and build number..."
        echo "📋 Build parameters:"
        echo "   Version: $VERSION"
        echo "   Build Number: $BUILD_NUMBER"
        echo "   Expected pubspec.yaml version: $VERSION+$BUILD_NUMBER"
        
        # Verify pubspec.yaml has correct version before building
        echo "🔍 Verifying pubspec.yaml version..."
        grep "version:" pubspec.yaml || echo "No version found in pubspec.yaml"
        
        flutter build ios --release --no-codesign --build-name="$VERSION" --build-number="$BUILD_NUMBER"
        
        # Create archive with manual signing ONLY for Runner target
        echo "📦 Creating archive with manual signing for Runner target only..."
        
        # Debug: Show current signing configuration before build
        echo "🔍 Pre-build signing verification..."
        echo "📋 Available certificates in keychain:"
        security find-identity -v -p codesigning build.keychain
        echo "📋 Runner project signing settings:"
        grep -A 3 -B 3 -E "(CODE_SIGN_STYLE|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER)" ios/Runner.xcodeproj/project.pbxproj || echo "No signing settings found"
        echo "📋 Current environment variables:"
        echo "   CERT_NAME: $CERT_NAME"
        echo "   PROFILE_UUID: $PROFILE_UUID"
        echo "   APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}"
        
        xcodebuild -workspace ios/Runner.xcworkspace \
          -scheme Runner \
          -configuration Release \
          -destination generic/platform=iOS \
          -archivePath build/ios/Runner.xcarchive \
          CURRENT_PROJECT_VERSION="$BUILD_NUMBER" \
          MARKETING_VERSION="$VERSION" \
          ASSETCATALOG_COMPILER_APPICON_NAME="AppIcon" \
          archive
          
        # Debug: Verify the built app has correct version information
        echo "🔍 Verifying built app version information..."
        if [ -f "build/ios/Runner.xcarchive/Products/Applications/Runner.app/Info.plist" ]; then
          echo "📋 App Info.plist version info:"
          /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "build/ios/Runner.xcarchive/Products/Applications/Runner.app/Info.plist" || echo "No CFBundleShortVersionString found"
          /usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "build/ios/Runner.xcarchive/Products/Applications/Runner.app/Info.plist" || echo "No CFBundleVersion found"
          /usr/libexec/PlistBuddy -c "Print :CFBundleIconName" "build/ios/Runner.xcarchive/Products/Applications/Runner.app/Info.plist" || echo "No CFBundleIconName found"
          echo "📦 CFBundleIcons in built app:"
          /usr/libexec/PlistBuddy -c "Print :CFBundleIcons" "build/ios/Runner.xcarchive/Products/Applications/Runner.app/Info.plist" || echo "(no CFBundleIcons)"
        else
          echo "❌ App Info.plist not found at expected location"
          echo "📁 Archive contents:"
          find build/ios/Runner.xcarchive -name "*.plist" | head -5
        fi
          
        # Export IPA
        echo " Exporting IPA..."
        
        # Debug: Verify provisioning profile and export options before export
        echo "🔍 PRE-EXPORT DEBUG: Verifying provisioning profile availability..."
        echo "📋 Available provisioning profiles:"
        ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ || echo "No provisioning profiles directory found"
        
        echo "📋 Provisioning profile details:"
        if [ -f ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision ]; then
          security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | plutil -p - | head -20
          echo "📱 Profile UUID: $PROFILE_UUID"
          echo "📱 Bundle ID in profile:"
          security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | plutil -extract Entitlements.application-identifier xml1 -o - - | xmllint --xpath "//string/text()" - || echo "Could not extract bundle ID"
        else
          echo "❌ Provisioning profile file not found!"
        fi
        
        echo "📋 Current exportOptions.plist content:"
        cat ios/exportOptions.plist
        
        echo "📋 Archive contents:"
        ls -la build/ios/Runner.xcarchive/
        ls -la build/ios/Runner.xcarchive/Products/Applications/ || echo "No Applications directory"
        
        # Update exportOptions.plist to include provisioning profile mapping for manual signing
        echo "🔧 Updating exportOptions.plist with provisioning profile mapping..."
        {
          echo '<?xml version="1.0" encoding="UTF-8"?>'
          echo '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">'
          echo '<plist version="1.0">'
          echo '<dict>'
          echo '    <key>method</key>'
          echo '    <string>app-store</string>'
          echo '    <key>teamID</key>'
          echo "    <string>${{ secrets.APPLE_TEAM_ID }}</string>"
          echo '    <key>uploadBitcode</key>'
          echo '    <false/>'
          echo '    <key>uploadSymbols</key>'
          echo '    <true/>'
          echo '    <key>compileBitcode</key>'
          echo '    <false/>'
          echo '    <key>signingStyle</key>'
          echo '    <string>manual</string>'
          echo '    <key>signingCertificate</key>'
          echo '    <string>Apple Distribution</string>'
          echo '    <key>provisioningProfiles</key>'
          echo '    <dict>'
          echo '        <key>com.visios.nocode</key>'
          echo "        <string>$PROFILE_UUID</string>"
          echo '    </dict>'
          echo '</dict>'
          echo '</plist>'
        } > ios/exportOptions.plist
        
        echo "📋 Updated exportOptions.plist content:"
        cat ios/exportOptions.plist
        
        xcodebuild -exportArchive \
          -archivePath build/ios/Runner.xcarchive \
          -exportPath build/ios/ipa \
          -exportOptionsPlist ios/exportOptions.plist
          
    - name: Upload to TestFlight
      env:
        APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
      run: |
        cd flutter_project
        echo "📤 Uploading to TestFlight..."
        
        # Debug: Verify .p8 file before upload
        echo "🔍 PRE-UPLOAD P8 VERIFICATION..."
        P8_PATH="~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8"
        echo "📁 Expected P8 path: $P8_PATH"
        
        if [ -f ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8 ]; then
          echo "✅ P8 file still exists before upload"
          echo "📊 File size: $(wc -c < ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8) bytes"
          echo "🔐 File permissions: $(ls -la ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          
          # Test if altool can read the file
          echo "🧪 Testing altool access to P8 file..."
          if [ -r ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8 ]; then
            echo "✅ P8 file is readable"
          else
            echo "❌ P8 file is not readable"
          fi
          
          # Show first and last few lines to verify format
          echo "📝 P8 file content verification:"
          echo "   First line: $(head -n 1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          echo "   Last line: $(tail -n 1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          
        else
          echo "❌ P8 file missing before upload!"
          echo "📁 Current directory contents:"
          ls -la ~/private_keys/ || echo "private_keys directory missing"
        fi
        
        echo "🔑 App Store Connect credentials:"
        echo "   Issuer ID: $APP_STORE_CONNECT_ISSUER_ID"
        echo "   Key ID: $APP_STORE_CONNECT_KEY_ID"
        echo "   P8 file expected at: ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8"
        
        # Find the IPA file
        IPA_PATH=$(find build/ios/ipa -name "*.ipa" | head -n 1)
        echo "📱 IPA Path: $IPA_PATH"
        
        if [ -f "$IPA_PATH" ]; then
          echo "✅ IPA file exists: $(ls -lh "$IPA_PATH")"
        else
          echo "❌ IPA file not found!"
          echo "📁 Build directory contents:"
          ls -la build/ios/ipa/ || echo "IPA directory missing"
        fi
        
        # Upload using altool
        xcrun altool --upload-app \
          --type ios \
          --file "$IPA_PATH" \
          --apiKey $APP_STORE_CONNECT_KEY_ID \
          --apiIssuer $APP_STORE_CONNECT_ISSUER_ID \
          --show-progress
          
    - name: Notify success and export outputs
      if: ${{ success() }}
      id: notify_success
      run: |
        echo "✅ TestFlight deployment completed successfully!"
        echo "📱 App: $APP_NAME"
        echo "📦 Bundle ID: $BUNDLE_ID"
        echo "🔢 Version: $VERSION ($BUILD_NUMBER)"
        
        # Export step outputs (new syntax)
        echo "build_id=$BUILD_NUMBER" >> "$GITHUB_OUTPUT"
        echo "version=$VERSION" >> "$GITHUB_OUTPUT"
        echo "app_name=$APP_NAME" >> "$GITHUB_OUTPUT"
        echo "bundle_id=$BUNDLE_ID" >> "$GITHUB_OUTPUT"
        echo "status=success" >> "$GITHUB_OUTPUT"
        
        # Create a JSON file with build details
        cat > build_info.json << EOF
        {
          "buildId": "$BUILD_NUMBER",
          "version": "$VERSION",
          "appName": "$APP_NAME",
          "bundleId": "$BUNDLE_ID",
          "status": "success",
          "testFlightLink": "https://appstoreconnect.apple.com/apps",
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
        EOF
        
        echo "📄 Build info saved to build_info.json"
        cat build_info.json | cat

    - name: Upload build info artifact
      if: ${{ success() }}
      uses: actions/upload-artifact@v4
      with:
        name: build-info
        path: build_info.json

    - name: Notify failure
      if: ${{ failure() }}
      run: |
        echo "❌ TestFlight deployment failed!"
        echo "status=failed" >> "$GITHUB_OUTPUT"