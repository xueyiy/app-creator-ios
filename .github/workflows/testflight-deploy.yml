name: Deploy to TestFlight

on:
  workflow_dispatch:
    inputs:
      project_data:
        description: 'Project data JSON (from your app)'
        required: false
        type: string
        default: '{}'
      app_name:
        description: 'App name for the build'
        required: true
        type: string
        default: 'NoCodeApp'
      bundle_id:
        description: 'Bundle ID (used if project_data not provided)'
        required: false
        type: string
        default: 'com.visios.nocode'
      version:
        description: 'App Version (used if project_data not provided)'
        required: false
        type: string
        default: '1.0.1'
      build_number:
        description: 'Build Number (used if project_data not provided)'
        required: false
        type: string
        default: '1'
      backend_url:
        description: 'Backend URL for app generation (or use BACKEND_URL secret)'
        required: false
        type: string
        default: ''

jobs:
  deploy-testflight:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
        
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.19.0'
        channel: 'stable'
        
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
        
    - name: Create Flutter project structure
      run: |
        echo "üèóÔ∏è Creating Flutter project structure..."
        
        # Parse project data to extract app info
        echo "üìä Parsing project configuration..."
        PROJECT_DATA='${{ github.event.inputs.project_data }}'
        APP_NAME='${{ github.event.inputs.app_name }}'
        
        # Check if we have meaningful project_data (not just empty {})
        if [ "$PROJECT_DATA" != "{}" ] && [ "$PROJECT_DATA" != "" ]; then
          echo "üì± Using project_data for app configuration"
          # Extract deployment info from project data
          BUNDLE_ID=$(echo "$PROJECT_DATA" | jq -r '.deploymentInfo.bundleId // "${{ github.event.inputs.bundle_id }}"')
          VERSION=$(echo "$PROJECT_DATA" | jq -r '.deploymentInfo.version // "${{ github.event.inputs.version }}"')
          # Always generate fresh build number to avoid conflicts, ignore any existing buildNumber
          BUILD_NUMBER=$(date +%s)
          USE_PROJECT_DATA=true
          echo "üîÑ Generated fresh build number: $BUILD_NUMBER (ignoring any existing buildNumber)"
        else
          echo "üì± Using manual inputs for app configuration"
          # Use manual inputs but generate fresh build number
          BUNDLE_ID='${{ github.event.inputs.bundle_id }}'
          VERSION='${{ github.event.inputs.version }}'
          # Always generate fresh build number instead of using potentially old default
          BUILD_NUMBER=$(date +%s)
          USE_PROJECT_DATA=false
          echo "üîÑ Generated fresh build number: $BUILD_NUMBER (instead of manual input)"
          # Create minimal project data for backend call
          PROJECT_DATA='{"templateId":"default","projectId":"github-action-build","template":{},"deploymentInfo":{"appName":"'$APP_NAME'","bundleId":"'$BUNDLE_ID'","version":"'$VERSION'","buildNumber":"'$BUILD_NUMBER'"}}'
        fi
        
        echo "üì± Final App Configuration:"
        echo "   Name: $APP_NAME"
        echo "   Bundle ID: $BUNDLE_ID"
        echo "   Version: $VERSION"
        echo "   Build Number: $BUILD_NUMBER"
        echo "   Using Project Data: $USE_PROJECT_DATA"
        
        # Store in environment for later steps
        echo "BUNDLE_ID=$BUNDLE_ID" >> $GITHUB_ENV
        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
        echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
        echo "PROJECT_DATA=$PROJECT_DATA" >> $GITHUB_ENV
        
        mkdir -p flutter_project
        cd flutter_project
        
        # Initialize Flutter project
        flutter create . --org=$BUNDLE_ID --project-name=app
        
        # Create the app using our backend service
        echo "üì± Generating app from backend..."
        
        # Use BACKEND_URL secret if available, otherwise use input
        BACKEND_URL='${{ secrets.BACKEND_URL }}'
        if [ -z "$BACKEND_URL" ]; then
          BACKEND_URL='${{ github.event.inputs.backend_url }}'
        fi
        
        if [ -z "$BACKEND_URL" ]; then
          echo "‚ùå No backend URL provided! Please set BACKEND_URL secret or provide backend_url input"
          exit 1
        fi
        
        echo "üåê Using backend URL: $BACKEND_URL"
        curl -X POST "$BACKEND_URL/api/package-flutter" \
          -H "Content-Type: application/json" \
          -d "$PROJECT_DATA" \
          --output app_package.zip
          
        # Extract the generated app
        echo "üì¶ Extracting generated Flutter app..."
        unzip -o app_package.zip

        # Ensure ios/Runner/Info.plist has the correct version and build number
        echo "üîß Ensuring ios/Runner/Info.plist has correct MARKETING_VERSION and CURRENT_PROJECT_VERSION..."
        if [ -f ios/Runner/Info.plist ]; then
          echo "üìã Before patch:" 
          /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" ios/Runner/Info.plist || echo "(no CFBundleShortVersionString)"
          /usr/libexec/PlistBuddy -c "Print :CFBundleVersion" ios/Runner/Info.plist || echo "(no CFBundleVersion)"

          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" ios/Runner/Info.plist 2>/dev/null \
            || /usr/libexec/PlistBuddy -c "Add :CFBundleShortVersionString string $VERSION" ios/Runner/Info.plist
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD_NUMBER" ios/Runner/Info.plist 2>/dev/null \
            || /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $BUILD_NUMBER" ios/Runner/Info.plist

          echo "‚úÖ After patch:"
          /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" ios/Runner/Info.plist
          /usr/libexec/PlistBuddy -c "Print :CFBundleVersion" ios/Runner/Info.plist
        else
          echo "‚ùå ios/Runner/Info.plist not found after extraction"
          ls -la ios || true
        fi
        
        # Create exportOptions.plist for later use
        echo "üìù Creating exportOptions.plist..."
        cat > ios/exportOptions.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>app-store</string>
            <key>teamID</key>
            <string>${{ secrets.APPLE_TEAM_ID }}</string>
            <key>uploadBitcode</key>
            <false/>
            <key>uploadSymbols</key>
            <true/>
            <key>compileBitcode</key>
            <false/>
            <key>signingStyle</key>
            <string>manual</string>
            <key>signingCertificate</key>
            <string>Apple Distribution</string>
        </dict>
        </plist>
        EOF
        
    - name: Configure iOS signing
      env:
        APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
        APP_STORE_CONNECT_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_PRIVATE_KEY }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        IOS_CERTIFICATE_P12: ${{ secrets.IOS_CERTIFICATE_P12 }}
        IOS_CERTIFICATE_PASSWORD: ${{ secrets.IOS_CERTIFICATE_PASSWORD }}
        IOS_PROVISIONING_PROFILE: ${{ secrets.IOS_PROVISIONING_PROFILE }}
      run: |
        echo "üîê Setting up iOS code signing with manual certificates..."
        
        # Create private_keys directory for App Store Connect API
        mkdir -p ~/private_keys
        echo "$APP_STORE_CONNECT_PRIVATE_KEY" > ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8
        
        # Debug: Verify .p8 file creation and content
        echo "üîç P8 FILE DEBUG: Verifying AuthKey file creation..."
        P8_FILE_PATH="~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8"
        echo "üìÅ P8 file path: $P8_FILE_PATH"
        
        if [ -f ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8 ]; then
          echo "‚úÖ P8 file exists"
          echo "üìä File size: $(wc -c < ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8) bytes"
          echo "üîê File permissions: $(ls -la ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          echo "üìù First line: $(head -n 1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          echo "üìù Last line: $(tail -n 1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          echo "üìè Line count: $(wc -l < ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          
          # Validate .p8 format
          if head -n 1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8 | grep -q "BEGIN PRIVATE KEY"; then
            echo "‚úÖ P8 file has correct BEGIN header"
          else
            echo "‚ùå P8 file missing BEGIN PRIVATE KEY header"
          fi
          
          if tail -n 1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8 | grep -q "END PRIVATE KEY"; then
            echo "‚úÖ P8 file has correct END footer"
          else
            echo "‚ùå P8 file missing END PRIVATE KEY footer"
          fi
        else
          echo "‚ùå P8 file does not exist!"
          echo "üìÅ Directory contents:"
          ls -la ~/private_keys/ || echo "Directory does not exist"
        fi
        
        # Set up manual signing with certificates (more reliable than automatic)
        if [ -n "$IOS_CERTIFICATE_P12" ] && [ -n "$IOS_CERTIFICATE_PASSWORD" ]; then
          echo "üìã Setting up manual signing certificates..."
          
          # Setup keychain
          security create-keychain -p "build-keychain-password" build.keychain
          security list-keychains -s build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "build-keychain-password" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain
          
          # Import certificate
          echo "$IOS_CERTIFICATE_P12" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P "$IOS_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/xcodebuild
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "build-keychain-password" build.keychain
          
          # Debug: Comprehensive certificate analysis after import
          echo "üîç CERTIFICATE DEBUG: Analyzing imported certificate..."
          echo "üìã Certificate file info:"
          openssl pkcs12 -in certificate.p12 -nokeys -passin pass:"$IOS_CERTIFICATE_PASSWORD" | openssl x509 -noout -subject -dates -purpose || echo "Failed to analyze certificate with openssl"
          
          echo "üìã All certificates in keychain (detailed):"
          security find-identity -v build.keychain
          
          echo "üìã Certificates by type:"
          security find-identity -v -p codesigning build.keychain | grep -i "distribution" && echo "‚úÖ Distribution certificates found" || echo "‚ùå No Distribution certificates"
          security find-identity -v -p codesigning build.keychain | grep -i "development" && echo "‚úÖ Development certificates found" || echo "‚ùå No Development certificates"
          
          echo "üìã Certificate details for code signing:"
          security find-identity -v -p codesigning build.keychain
          
          # Install provisioning profile
          if [ -n "$IOS_PROVISIONING_PROFILE" ]; then
            mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
            echo "$IOS_PROVISIONING_PROFILE" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision
            
            # Get the provisioning profile UUID for manual signing
            PROFILE_UUID=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | plutil -extract UUID xml1 -o - - | xmllint --xpath "//string/text()" -)
            echo "üì± Provisioning Profile UUID: $PROFILE_UUID"
            echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV
          fi
          
          # Get certificate common name for code signing identity  
          echo "üîç CERTIFICATE SELECTION: Finding the correct certificate..."
          
          # First, try to get Distribution certificate specifically (required for TestFlight)
          DIST_CERT=$(security find-identity -v -p codesigning build.keychain | grep -i "distribution" | head -n 1 | grep -o '"[^"]*"' | sed 's/"//g')
          
          if [ -n "$DIST_CERT" ]; then
            echo "üéØ Found Distribution certificate: $DIST_CERT"
            CERT_NAME="$DIST_CERT"
          else
            # Fallback to any certificate if Distribution not found
            CERT_NAME=$(security find-identity -v -p codesigning build.keychain | head -n 1 | grep -o '"[^"]*"' | sed 's/"//g')
            echo "‚ö†Ô∏è No Distribution certificate found, using first available: $CERT_NAME"
          fi
          
          echo "üîë Selected Certificate Identity: $CERT_NAME"
          echo "CERT_NAME=$CERT_NAME" >> $GITHUB_ENV
          
          # Verify the certificate is correct for App Store distribution
          if echo "$CERT_NAME" | grep -qi "distribution"; then
            echo "‚úÖ Using Distribution certificate (correct for TestFlight)"
          else
            echo "‚ö†Ô∏è Warning: Not using Distribution certificate - this may cause issues with TestFlight upload"
          fi
        else
          echo "‚ùå No manual signing certificates provided!"
          exit 1
        fi
        
        # Verify setup
        echo "üîç Verifying signing setup..."
        echo "   Team ID: $APPLE_TEAM_ID"
        echo "   Bundle ID: com.visios.nocode"
        echo "   Certificate: $CERT_NAME"
        echo "   Profile UUID: $PROFILE_UUID"
        
    - name: Build iOS app
      run: |
        cd flutter_project
        echo "üî® Building Flutter iOS app with manual signing..."
        
        # Simple approach: Remove and add signing settings  
        TEAM_ID="${{ secrets.APPLE_TEAM_ID }}"
        PROFILE_UUID="$PROFILE_UUID"
        
        echo "üîß Configuring Runner target signing (manual) and Pods targets (automatic)..."
        
        # First, remove ALL existing signing settings from project
        sed -i '' '/CODE_SIGN_STYLE/d' ios/Runner.xcodeproj/project.pbxproj
        sed -i '' '/DEVELOPMENT_TEAM/d' ios/Runner.xcodeproj/project.pbxproj  
        sed -i '' '/PROVISIONING_PROFILE_SPECIFIER/d' ios/Runner.xcodeproj/project.pbxproj
        sed -i '' '/CODE_SIGN_IDENTITY/d' ios/Runner.xcodeproj/project.pbxproj
        
        # Only add manual signing to Runner's bundle identifier
        echo "			CODE_SIGN_STYLE = Manual;" > temp_runner_signing.txt
        echo "			DEVELOPMENT_TEAM = \"$TEAM_ID\";" >> temp_runner_signing.txt  
        echo "			PROVISIONING_PROFILE_SPECIFIER = \"$PROFILE_UUID\";" >> temp_runner_signing.txt
        echo "			CODE_SIGN_IDENTITY = \"$CERT_NAME\";" >> temp_runner_signing.txt
        
        # Insert signing settings only after Runner's bundle identifier
        sed -i '' '/PRODUCT_BUNDLE_IDENTIFIER = com\.visios\.nocode;/r temp_runner_signing.txt' ios/Runner.xcodeproj/project.pbxproj
        rm temp_runner_signing.txt
        
        echo "üîç Signing settings added to project:"
        grep -E "(CODE_SIGN_STYLE|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER)" ios/Runner.xcodeproj/project.pbxproj || echo "No signing settings found"
        
        # Get dependencies first to regenerate Pods with clean settings
        echo "üì¶ Running flutter pub get to regenerate Pods..."
        flutter pub get
        
        # Ensure CocoaPods targets use automatic signing (DO NOT specify provisioning profiles)
        if [ -f "ios/Pods/Pods.xcodeproj/project.pbxproj" ]; then
          echo "üîß Ensuring CocoaPods targets use automatic signing..."
          sed -i '' 's/CODE_SIGN_STYLE = Manual;/CODE_SIGN_STYLE = Automatic;/g' ios/Pods/Pods.xcodeproj/project.pbxproj
          sed -i '' 's/DEVELOPMENT_TEAM = "";/DEVELOPMENT_TEAM = "${{ secrets.APPLE_TEAM_ID }}";/g' ios/Pods/Pods.xcodeproj/project.pbxproj
          # COMPLETELY REMOVE any provisioning profile specifiers from Pods targets (not just empty them)
          sed -i '' '/PROVISIONING_PROFILE_SPECIFIER/d' ios/Pods/Pods.xcodeproj/project.pbxproj
        fi
        
        # Fix Pods/Pods-Runner targets for automatic signing (clear out any code signing that may be left)
        PBXPROJ="ios/Pods/Pods.xcodeproj/project.pbxproj"
        if [ -f "$PBXPROJ" ]; then
          echo "üîß Completely removing all code signing from Pods targets"
          
          # Debug: Show Pods signing settings before cleanup
          echo "üîç Pods signing settings before cleanup:"
          grep -E "(CODE_SIGN_STYLE|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER|CODE_SIGN_IDENTITY)" $PBXPROJ || echo "No signing settings found in Pods"
          
          # Set automatic signing for Pods
          sed -i '' 's/CODE_SIGN_STYLE = Manual;/CODE_SIGN_STYLE = Automatic;/g' $PBXPROJ
          
          # COMPLETELY REMOVE all problematic signing settings from Pods (not just empty them)
          sed -i '' '/PROVISIONING_PROFILE_SPECIFIER/d' $PBXPROJ  # Remove entire lines with provisioning profiles
          sed -i '' '/DEVELOPMENT_TEAM = .*/d' $PBXPROJ  # Remove DEVELOPMENT_TEAM lines from Pods
          sed -i '' '/CODE_SIGN_IDENTITY = .*/d' $PBXPROJ  # Remove CODE_SIGN_IDENTITY lines from Pods
          
          # Debug: Show Pods signing settings after cleanup
          echo "üîç Pods signing settings after cleanup:"
          grep -E "(CODE_SIGN_STYLE|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER|CODE_SIGN_IDENTITY)" $PBXPROJ || echo "No signing settings found in Pods"
        fi
        
        # Final verification before build
        echo "üîç Final check: Any provisioning profile in Pods pbxproj?"
        grep "PROVISIONING_PROFILE_SPECIFIER" ios/Pods/Pods.xcodeproj/project.pbxproj || echo "‚úÖ All provisioning profiles removed from Pods."

        # Comprehensive CocoaPods cleanup and verification
        PBXPROJ="ios/Pods/Pods.xcodeproj/project.pbxproj"
        if [ -f "$PBXPROJ" ]; then
          echo "üîß Comprehensive CocoaPods cleanup (removing ALL signing overrides)"
          
          # Debug: Show Pods signing settings before cleanup
          echo "üîç Pods signing settings before cleanup:"
          grep -E "(CODE_SIGN_STYLE|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER|CODE_SIGN_IDENTITY)" $PBXPROJ || echo "No signing settings found in Pods"
          
          # Set automatic signing for all Pods targets
          sed -i '' 's/CODE_SIGN_STYLE = Manual;/CODE_SIGN_STYLE = Automatic;/g' $PBXPROJ
          
          # COMPLETELY REMOVE all problematic signing settings from Pods (not just empty them)
          # This prevents plugins like sqflite, shared_preferences from having ANY provisioning profile lines
          sed -i '' '/PROVISIONING_PROFILE_SPECIFIER/d' $PBXPROJ  # Remove entire lines with provisioning profiles
          sed -i '' '/DEVELOPMENT_TEAM = .*/d' $PBXPROJ  # Remove DEVELOPMENT_TEAM lines from Pods
          sed -i '' '/CODE_SIGN_IDENTITY = .*/d' $PBXPROJ  # Remove CODE_SIGN_IDENTITY lines from Pods
          
          # Debug: Show Pods signing settings after cleanup
          echo "üîç Pods signing settings after cleanup:"
          grep -E "(CODE_SIGN_STYLE|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER|CODE_SIGN_IDENTITY)" $PBXPROJ || echo "No signing settings found in Pods"
        fi
        
        # Final verification before build
        echo "üîç Final check: Any provisioning profile in Pods pbxproj?"
        grep "PROVISIONING_PROFILE_SPECIFIER" ios/Pods/Pods.xcodeproj/project.pbxproj || echo "‚úÖ All provisioning profiles removed from Pods."
        
        # Build iOS with no code signing first
        echo "üî® Building Flutter iOS app with explicit version and build number..."
        echo "üìã Build parameters:"
        echo "   Version: $VERSION"
        echo "   Build Number: $BUILD_NUMBER"
        echo "   Expected pubspec.yaml version: $VERSION+$BUILD_NUMBER"
        
        # Verify pubspec.yaml has correct version before building
        echo "üîç Verifying pubspec.yaml version..."
        grep "version:" pubspec.yaml || echo "No version found in pubspec.yaml"
        
        flutter build ios --release --no-codesign --build-name="$VERSION" --build-number="$BUILD_NUMBER"
        
        # Create archive with manual signing ONLY for Runner target
        echo "üì¶ Creating archive with manual signing for Runner target only..."
        
        # Debug: Show current signing configuration before build
        echo "üîç Pre-build signing verification..."
        echo "üìã Available certificates in keychain:"
        security find-identity -v -p codesigning build.keychain
        echo "üìã Runner project signing settings:"
        grep -A 3 -B 3 -E "(CODE_SIGN_STYLE|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER)" ios/Runner.xcodeproj/project.pbxproj || echo "No signing settings found"
        echo "üìã Current environment variables:"
        echo "   CERT_NAME: $CERT_NAME"
        echo "   PROFILE_UUID: $PROFILE_UUID"
        echo "   APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}"
        
        xcodebuild -workspace ios/Runner.xcworkspace \
          -scheme Runner \
          -configuration Release \
          -destination generic/platform=iOS \
          -archivePath build/ios/Runner.xcarchive \
          CURRENT_PROJECT_VERSION="$BUILD_NUMBER" \
          MARKETING_VERSION="$VERSION" \
          archive
          
        # Debug: Verify the built app has correct version information
        echo "üîç Verifying built app version information..."
        if [ -f "build/ios/Runner.xcarchive/Products/Applications/Runner.app/Info.plist" ]; then
          echo "üìã App Info.plist version info:"
          /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "build/ios/Runner.xcarchive/Products/Applications/Runner.app/Info.plist" || echo "No CFBundleShortVersionString found"
          /usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "build/ios/Runner.xcarchive/Products/Applications/Runner.app/Info.plist" || echo "No CFBundleVersion found"
        else
          echo "‚ùå App Info.plist not found at expected location"
          echo "üìÅ Archive contents:"
          find build/ios/Runner.xcarchive -name "*.plist" | head -5
        fi
          
        # Export IPA
        echo " Exporting IPA..."
        
        # Debug: Verify provisioning profile and export options before export
        echo "üîç PRE-EXPORT DEBUG: Verifying provisioning profile availability..."
        echo "üìã Available provisioning profiles:"
        ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ || echo "No provisioning profiles directory found"
        
        echo "üìã Provisioning profile details:"
        if [ -f ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision ]; then
          security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | plutil -p - | head -20
          echo "üì± Profile UUID: $PROFILE_UUID"
          echo "üì± Bundle ID in profile:"
          security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | plutil -extract Entitlements.application-identifier xml1 -o - - | xmllint --xpath "//string/text()" - || echo "Could not extract bundle ID"
        else
          echo "‚ùå Provisioning profile file not found!"
        fi
        
        echo "üìã Current exportOptions.plist content:"
        cat ios/exportOptions.plist
        
        echo "üìã Archive contents:"
        ls -la build/ios/Runner.xcarchive/
        ls -la build/ios/Runner.xcarchive/Products/Applications/ || echo "No Applications directory"
        
        # Update exportOptions.plist to include provisioning profile mapping for manual signing
        echo "üîß Updating exportOptions.plist with provisioning profile mapping..."
        {
          echo '<?xml version="1.0" encoding="UTF-8"?>'
          echo '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">'
          echo '<plist version="1.0">'
          echo '<dict>'
          echo '    <key>method</key>'
          echo '    <string>app-store</string>'
          echo '    <key>teamID</key>'
          echo "    <string>${{ secrets.APPLE_TEAM_ID }}</string>"
          echo '    <key>uploadBitcode</key>'
          echo '    <false/>'
          echo '    <key>uploadSymbols</key>'
          echo '    <true/>'
          echo '    <key>compileBitcode</key>'
          echo '    <false/>'
          echo '    <key>signingStyle</key>'
          echo '    <string>manual</string>'
          echo '    <key>signingCertificate</key>'
          echo '    <string>Apple Distribution</string>'
          echo '    <key>provisioningProfiles</key>'
          echo '    <dict>'
          echo '        <key>com.visios.nocode</key>'
          echo "        <string>$PROFILE_UUID</string>"
          echo '    </dict>'
          echo '</dict>'
          echo '</plist>'
        } > ios/exportOptions.plist
        
        echo "üìã Updated exportOptions.plist content:"
        cat ios/exportOptions.plist
        
        xcodebuild -exportArchive \
          -archivePath build/ios/Runner.xcarchive \
          -exportPath build/ios/ipa \
          -exportOptionsPlist ios/exportOptions.plist
          
    - name: Upload to TestFlight
      env:
        APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
      run: |
        cd flutter_project
        echo "üì§ Uploading to TestFlight..."
        
        # Debug: Verify .p8 file before upload
        echo "üîç PRE-UPLOAD P8 VERIFICATION..."
        P8_PATH="~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8"
        echo "üìÅ Expected P8 path: $P8_PATH"
        
        if [ -f ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8 ]; then
          echo "‚úÖ P8 file still exists before upload"
          echo "üìä File size: $(wc -c < ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8) bytes"
          echo "üîê File permissions: $(ls -la ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          
          # Test if altool can read the file
          echo "üß™ Testing altool access to P8 file..."
          if [ -r ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8 ]; then
            echo "‚úÖ P8 file is readable"
          else
            echo "‚ùå P8 file is not readable"
          fi
          
          # Show first and last few lines to verify format
          echo "üìù P8 file content verification:"
          echo "   First line: $(head -n 1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          echo "   Last line: $(tail -n 1 ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8)"
          
        else
          echo "‚ùå P8 file missing before upload!"
          echo "üìÅ Current directory contents:"
          ls -la ~/private_keys/ || echo "private_keys directory missing"
        fi
        
        echo "üîë App Store Connect credentials:"
        echo "   Issuer ID: $APP_STORE_CONNECT_ISSUER_ID"
        echo "   Key ID: $APP_STORE_CONNECT_KEY_ID"
        echo "   P8 file expected at: ~/private_keys/AuthKey_$APP_STORE_CONNECT_KEY_ID.p8"
        
        # Find the IPA file
        IPA_PATH=$(find build/ios/ipa -name "*.ipa" | head -n 1)
        echo "üì± IPA Path: $IPA_PATH"
        
        if [ -f "$IPA_PATH" ]; then
          echo "‚úÖ IPA file exists: $(ls -lh "$IPA_PATH")"
        else
          echo "‚ùå IPA file not found!"
          echo "üìÅ Build directory contents:"
          ls -la build/ios/ipa/ || echo "IPA directory missing"
        fi
        
        # Upload using altool
        xcrun altool --upload-app \
          --type ios \
          --file "$IPA_PATH" \
          --apiKey $APP_STORE_CONNECT_KEY_ID \
          --apiIssuer $APP_STORE_CONNECT_ISSUER_ID \
          --show-progress
          
    - name: Notify completion
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "‚úÖ TestFlight deployment completed successfully!"
          echo "üì± App: $APP_NAME"
          echo "üì¶ Bundle ID: $BUNDLE_ID"
          echo "üî¢ Version: $VERSION ($BUILD_NUMBER)"
        else
          echo "‚ùå TestFlight deployment failed!"
        fi 