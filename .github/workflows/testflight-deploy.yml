name: Deploy to TestFlight

on:
  workflow_dispatch:
    inputs:
      project_data:
        description: 'Project data JSON (from your app)'
        required: true
        type: string
      app_name:
        description: 'App name for the build'
        required: true
        type: string
        default: 'NoCodeApp'

jobs:
  deploy:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: 'backend/package-lock.json'
        
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.32.1'
        channel: 'stable'
        
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
        
    - name: Verify Flutter setup
      run: |
        flutter doctor -v
        flutter --version
        echo "âœ… Dart SDK version check:"
        dart --version
        
    - name: Install Flutter dependencies
      run: |
        cd flutter_app
        flutter pub get
        flutter clean
        
    - name: Create private key file
      run: |
        mkdir -p ~/private_keys
        echo "${{ secrets.APP_STORE_CONNECT_PRIVATE_KEY }}" > ~/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8
        chmod 600 ~/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8
        echo "âœ… Private key file created"
        
    - name: Install Node.js dependencies
      timeout-minutes: 10
      run: |
        echo "ğŸ“¦ Installing Node.js dependencies..."
        echo "ğŸ“ Current directory: $(pwd)"
        echo "ğŸ“ Backend directory contents:"
        ls -la backend/
        echo ""
        echo "ğŸ“„ Package.json contents:"
        cat backend/package.json
        echo ""
        echo "ğŸ”„ Starting npm install..."
        
        cd backend
        
        # Clear npm cache first
        npm cache clean --force
        
        # Install with optimized settings for CI/CD
        npm install --verbose --no-audit --no-fund --prefer-offline --no-optional
        
        echo "âœ… Node.js dependencies installed successfully"
        echo "ğŸ“¦ Installed packages:"
        npm list --depth=0
        
    - name: Build and deploy to TestFlight
      timeout-minutes: 20
      env:
        APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
        APP_STORE_CONNECT_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_PRIVATE_KEY }}
        BUNDLE_ID: ${{ secrets.BUNDLE_ID }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        NODE_ENV: production
        FORCE_REAL_BUILDS: true
      run: |
        echo "ğŸš€ Starting TestFlight deployment..."
        echo "ğŸ“± App Name: ${{ github.event.inputs.app_name }}"
        echo "ğŸ”§ Environment: Production with real builds"
        echo "ğŸ“ Repository structure (minimal iOS build repo):"
        ls -la
        
        cd backend
        
        # Create deployment script that uses direct Flutter build
        cat > deploy.js << 'EOF'
        const TestFlightService = require('./testflight-service');
        const { spawn } = require('child_process');
        const fs = require('fs');
        const path = require('path');
        
        async function deploy() {
          try {
            const service = new TestFlightService();
            const projectData = JSON.parse(process.env.PROJECT_DATA);
            const appName = process.env.APP_NAME;
            
            console.log('ğŸ“¦ Updating Flutter app with project data...');
            
            // Update the Flutter app with the project data
            const flutterProjectPath = path.join(__dirname, '..', 'flutter_app');
            const buildNumber = Math.floor(Date.now() / 1000);
            const version = '1.0.0';
            
            await service.updateFlutterApp(flutterProjectPath, projectData, buildNumber, version);
            console.log('âœ… Flutter app updated successfully');
            
            console.log('ğŸ”¨ Building Flutter iOS app...');
            
            // Build Flutter app directly (not through packageFlutterApp)
            await new Promise((resolve, reject) => {
              const flutterBuild = spawn('flutter', ['build', 'ios', '--release'], {
                cwd: flutterProjectPath,
                stdio: 'inherit'
              });
              
              flutterBuild.on('close', (code) => {
                if (code === 0) {
                  console.log('âœ… Flutter build completed');
                  resolve();
                } else {
                  reject(new Error(`Flutter build failed with code ${code}`));
                }
              });
            });
            
            console.log('ğŸ“¦ Creating IPA...');
            
            // Create exportOptions.plist for App Store distribution
            const xmlDeclaration = '<?xml version="1.0" encoding="UTF-8"?>';
            const doctype = '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">';
            const exportOptionsContent = \`\${xmlDeclaration}
            \${doctype}
            <plist version="1.0">
            <dict>
              <key>method</key>
              <string>app-store</string>
              <key>teamID</key>
              <string>\${process.env.APPLE_TEAM_ID}</string>
              <key>uploadBitcode</key>
              <false/>
              <key>uploadSymbols</key>
              <true/>
              <key>compileBitcode</key>
              <false/>
              <key>manageAppVersionAndBuildNumber</key>
              <true/>
              <key>destination</key>
              <string>export</string>
              <key>signingStyle</key>
              <string>automatic</string>
            </dict>
            </plist>\`;
            
            const exportOptionsPath = path.join(flutterProjectPath, 'exportOptions.plist');
            fs.writeFileSync(exportOptionsPath, exportOptionsContent);
            
            // Archive and export IPA
            const archivePath = path.join(flutterProjectPath, 'build', 'Runner.xcarchive');
            const ipaPath = path.join(flutterProjectPath, 'build', 'Runner.ipa');
            
            console.log('ğŸ—ï¸ Archiving with xcodebuild...');
            await new Promise((resolve, reject) => {
              const archiveCmd = [
                'archive',
                '-workspace', path.join(flutterProjectPath, 'ios', 'Runner.xcworkspace'),
                '-scheme', 'Runner',
                '-archivePath', archivePath,
                '-configuration', 'Release',
                '-destination', 'generic/platform=iOS'
              ];
              
              const xcodebuild = spawn('xcodebuild', archiveCmd, {
                stdio: 'inherit'
              });
              
              xcodebuild.on('close', (code) => {
                if (code === 0) {
                  console.log('âœ… Archive completed');
                  resolve();
                } else {
                  reject(new Error(`Archive failed with code ${code}`));
                }
              });
            });
            
            console.log('ğŸ“¦ Exporting IPA...');
            await new Promise((resolve, reject) => {
              const exportCmd = [
                '-exportArchive',
                '-archivePath', archivePath,
                '-exportPath', path.dirname(ipaPath),
                '-exportOptionsPlist', exportOptionsPath
              ];
              
              const xcodebuild = spawn('xcodebuild', exportCmd, {
                stdio: 'inherit'
              });
              
              xcodebuild.on('close', (code) => {
                if (code === 0) {
                  console.log('âœ… IPA export completed');
                  resolve();
                } else {
                  reject(new Error(`IPA export failed with code ${code}`));
                }
              });
            });
            
            console.log('ğŸ“¤ Uploading to TestFlight...');
            const appConfig = {
              bundleId: process.env.BUNDLE_ID,
              teamId: process.env.APPLE_TEAM_ID
            };
            
            const upload = await service.uploadBuild(ipaPath, appConfig);
            console.log('âœ… Upload completed:', upload.id);
            
            console.log('ğŸ”— Generating public link...');
            const link = await service.generatePublicLink(upload.id);
            console.log('âœ… Public link generated');
            
            console.log('ğŸ‰ Deployment successful!');
            console.log('ğŸ“± Build ID:', upload.id);
            console.log('ğŸ”— TestFlight Link:', link.publicLink);
            
            // Set output for GitHub Actions
            console.log('::set-output name=build_id::' + upload.id);
            console.log('::set-output name=testflight_link::' + link.publicLink);
            
          } catch (error) {
            console.error('âŒ Deployment failed:', error.message);
            console.error('ğŸ“‹ Error stack:', error.stack);
            process.exit(1);
          }
        }
        
        deploy();
        EOF
        
        # Run deployment
        PROJECT_DATA='${{ github.event.inputs.project_data }}' APP_NAME='${{ github.event.inputs.app_name }}' node deploy.js
        
    - name: Display deployment results
      run: |
        echo "ğŸ‰ Deployment completed successfully!"
        echo "ğŸ“± Build ID: ${{ steps.deploy.outputs.build_id }}"
        echo "ğŸ”— TestFlight Link: ${{ steps.deploy.outputs.testflight_link }}"
        
    - name: Cleanup
      if: always()
      run: |
        echo "ğŸ§¹ Cleaning up..."
        rm -rf ~/private_keys
        echo "âœ… Cleanup completed" 